import{atom,isAtom,throwReatomError,__count,isAction,action}from"@reatom/core";import{onCtxAbort,__thenReatomed}from"@reatom/effects";import{onUpdate}from"@reatom/hooks";import{merge,isRec,noop,isShallowEqual,assign}from"@reatom/utils";import{isLinkedListAtom}from"@reatom/primitives";const mapName=({__reatom:proto},operator,name)=>name??`${proto.name}.${operator}`;function match(expression,name=__count("match")){const cases=[];let _truthy,_falsy,_default;const matchAtom=atom(ctxSpy=>{const value=isAtom(expression)?ctxSpy.spy(expression):"function"==typeof expression?expression(ctxSpy):expression,ctx=merge(ctxSpy,{spy:void 0}),list=[...cases,_truthy,_falsy,_default].filter(Boolean);for(const{clause:clause,statement:statement}of list)if(clause(ctx,value))return isAtom(statement)?ctxSpy.spy(statement):"function"==typeof statement?statement(ctxSpy,value):statement},name);return Object.assign(matchAtom,{is:(clause,statement)=>(cases.push({clause:isAtom(clause)?(ctx,value)=>Object.is(value,ctx.get(clause)):"function"==typeof clause?clause:(ctx,value)=>Object.is(value,clause),statement:statement}),matchAtom),with:(part,statement)=>(cases.push({clause:(ctx,expr)=>{const visit=(part,expr)=>{if(isRec(part)){for(const key in part)if(!visit(part[key],expr[key]))return!1;return!0}return Object.is(part,expr)};return visit(part,expr)},statement:statement}),matchAtom),truthy:statement=>(throwReatomError(_truthy,"the case is already defined"),_truthy={clause:(ctx,value)=>!!value,statement:statement},matchAtom),falsy:statement=>(throwReatomError(_falsy,"the case is already defined"),_falsy={clause:(ctx,value)=>!value,statement:statement},matchAtom),default:(statement=(()=>throwReatomError(!0,"no match")))=>(throwReatomError(_default,"the case is already defined"),_default={clause:(ctx,value)=>!0,statement:statement},matchAtom)})}const ctxMap=new WeakMap,bind=(ctx,fn)=>{let fnMap=ctxMap.get(ctx);fnMap||ctxMap.set(ctx,fnMap=new WeakMap);let bfn=fnMap.get(fn);return bfn||fnMap.set(fn,bfn=fn.bind(null,ctx)),bfn},delay=(options,name)=>anAtom=>{const running=new WeakMap;let{min:minOption,max:maxOption,leading:leading=!0,trailing:trailing=!0,abortable:abortable=!0}=options;throwReatomError(void 0===minOption&&void 0===maxOption,"wrong options"),minOption = minOption ??maxOption,maxOption = maxOption ??Number.MAX_SAFE_INTEGER,name=mapName(anAtom,"delay",name);const minAtom=isAtom(minOption)?minOption:atom(minOption,`${name}._minAtom`),maxAtom=isAtom(maxOption)?maxOption:atom(maxOption,`${name}._maxAtom`),theAtom=atom((ctx,prevState)=>{const min=ctx.get(minAtom),max=ctx.get(maxAtom),startsKey=ctx.cause.listeners,depState=ctx.spy(anAtom);let state=ctx.cause.pubs.length?prevState:proto.isAction?[]:depState;if(ctx.cause.pubs.length){const now=Date.now(),isRunning=running.has(startsKey),start=running.get(startsKey)??now,skip=isRunning||!leading;state=skip?prevState:proto.isAction?[depState[0]]:depState;const delay=Math.max(0,Math.min(min,max-(now-start)));running.set(startsKey,start),ctx.schedule(()=>running.delete(startsKey),-1);const timeoutId=setTimeout(()=>ctx.get((read,acualize)=>{read(proto)===ctx.cause&&(running.delete(startsKey),trailing&&skip&&acualize(ctx,proto,(patchCtx,patch)=>{patch.state=proto.isAction?[depState.at(-1)]:depState}))}),delay);timeoutId.unref?.(),ctx.schedule(()=>clearTimeout(timeoutId),-1),abortable&&onCtxAbort(ctx,()=>clearTimeout(timeoutId))}else state=proto.isAction?[]:depState;return state},name),proto=theAtom.__reatom;return proto.isAction=anAtom.__reatom.isAction,theAtom.deps=[anAtom],theAtom},debounce=(min=1,name)=>anAtom=>delay({min:min,leading:!1,trailing:!0},mapName(anAtom,"debounce",name))(anAtom),throttle=(max=1,name)=>anAtom=>delay({max:max,leading:!0,trailing:!1},mapName(anAtom,"throttle",name))(anAtom),effect=(fn,name)=>anAtom=>{const{isAction:isAction}=anAtom.__reatom,theAtom=atom((ctx,state=[])=>{const resolve=(params,payload)=>ctx.get((read,acualize)=>{payload instanceof Promise?payload.then(payload=>resolve(params,payload)):acualize(ctx,ctx.cause.proto,(patchCtx,patch)=>{patch.state=[{params:params,payload:payload}]})});return ctx.spy(anAtom,value=>{isAction&&value.payload instanceof Promise?__thenReatomed(ctx,value.payload,payload=>ctx.schedule(()=>resolve([{params:value.params,payload:payload}],fn(ctx,payload,value.params)))):ctx.schedule(()=>resolve([value],isAction?fn(ctx,value.payload,value.params):fn(ctx,value)))}),ctx.spy=void 0,state??[]},mapName(anAtom,"effect",name));return theAtom.__reatom.isAction=!0,theAtom.deps=[anAtom],theAtom.unstable_unhook=onUpdate(theAtom,noop),theAtom},filter=(predicate,name)=>anAtom=>{const{isAction:isAction}=anAtom.__reatom;predicate = predicate ??isAction?()=>!0:(ctx,a,b)=>!isShallowEqual(a,b);const theAtom=atom((ctx,prevState)=>{const isInit=0===ctx.cause.pubs.length,state=ctx.spy(anAtom);return isAction?state.reduce((acc,call)=>predicate(ctx,call.payload,call.params)?[call]:acc,prevState??[]):isInit||predicate(ctx,state,prevState)?state:prevState},mapName(anAtom,"filter",name));return theAtom.deps=[anAtom],theAtom.__reatom.isAction=isAction,theAtom},onLensUpdate=onUpdate,toLens=deps=>anAtom=>assign(anAtom,{deps:(anAtom.deps??[]).concat(deps)}),parseAtoms=(ctx,value)=>{if(isAction(value))return value;for(isLinkedListAtom(value)&&(value=value.array);isAtom(value);)value=ctx.spy?ctx.spy(value):ctx.get(value);if("object"!=typeof value||null===value)return value;if(isRec(value)){const res={};for(const k in value)res[k]=parseAtoms(ctx,value[k]);return res}if(Array.isArray(value)){const res=[];for(const v of value)res.push(parseAtoms(ctx,v));return res}if(value instanceof Map){const res=new Map;for(const[k,v]of value)res.set(k,parseAtoms(ctx,v));return res}if(value instanceof Set){const res=new Set;for(const v of value)res.add(parseAtoms(ctx,v));return res}return value},sample=(signal,name)=>anAtom=>{name=mapName(anAtom,"sample",name);const{isAction:isAction}=anAtom.__reatom,_cacheAtom=atom(null,`${name}._cacheAtom`),theAtom=atom((ctx,prevState)=>{const isInit=0===ctx.cause.pubs.length;ctx.spy(anAtom,v=>_cacheAtom(ctx,isAction?[v]:v));let changed=!1;if(ctx.spy(signal,()=>changed=!0),changed&&(!isInit||signal.__reatom.isAction)){const state=ctx.get(_cacheAtom);return _cacheAtom(ctx,ctx.get(anAtom)),state}return!isInit||signal.__reatom.isAction&&changed?changed?ctx.get(_cacheAtom):prevState:isAction?[]:ctx.get(anAtom)},name);return theAtom.__reatom.isAction=isAction,theAtom.deps=[anAtom,signal],theAtom},mapAtom=atom(null,"select._map");mapAtom.__reatom.initState=()=>new WeakMap;const touchedMap=new WeakMap,select=(ctx,cb,equal=(()=>!1))=>{let touched=touchedMap.get(ctx);touched||touchedMap.set(ctx,touched=new Set);const map=ctx.get(mapAtom);let atoms=map.get(ctx.cause.proto);atoms||map.set(ctx.cause.proto,atoms=new Map);const selectSource=cb.toString();throwReatomError(touched.has(selectSource),'multiple select with the same "toString" representation is not allowed'),touched.add(selectSource);let selectAtom=atoms.get(selectSource);if(!selectAtom){let isInit=!0;atoms.set(selectSource,selectAtom=atom((ctx,prevState)=>{const newState=cb(ctx),resultState=isInit||!equal(prevState,newState)?newState:prevState;return isInit=!1,resultState},__count(`${ctx.cause.proto.name}._select`)))}return ctx.spy(selectAtom)},withReset=()=>anAtom=>Object.assign(anAtom,{reset:action(ctx=>ctx.get((read,actualize)=>actualize(ctx,anAtom.__reatom,(patchCtx,patch)=>patch.state=patch.proto.initState(ctx)).state),`${anAtom.__reatom.name}._reset`)}),combine=(shape,name=__count("_combine"))=>{const theAtom=atom(ctx=>{const newState={};for(const key in shape)newState[key]=ctx.spy(shape[key]);return newState},name);return theAtom.deps=Object.values(shape),theAtom},SKIP="REATOM_SKIP_MARK",readonly=({__reatom:__reatom,pipe:pipe,onChange:onChange,onCall:onCall,deps:deps})=>Object.assign({__reatom:__reatom,pipe:pipe,onChange:onChange},deps?{deps:deps}:{},onCall?{onCall:onCall}:{}),plain=anAtom=>{const theAtom="function"==typeof anAtom?anAtom.bind():{};return theAtom.__reatom=anAtom.__reatom,theAtom.pipe=anAtom.pipe,theAtom.onChange=anAtom.onChange,"onCall"in anAtom&&(theAtom.onCall=anAtom.onCall),theAtom},mapState=(mapper,name)=>anAtom=>{const theAtom=atom((ctx,state)=>mapper(ctx,ctx.spy(anAtom),ctx.cause.pubs.at(0)?.state,state),mapName(anAtom,"mapState",name));return theAtom.deps=[anAtom],theAtom},mapPayload=(fallbackOrMapper,mapOrName,name)=>anAction=>{throwReatomError(!anAction.__reatom.isAction,"action expected");const isAction="function"==typeof fallbackOrMapper;let fallback=fallbackOrMapper,map=mapOrName??((ctx,v)=>v);isAction&&(fallback=[],map=fallbackOrMapper,name=mapOrName);const theAtom=Object.assign(()=>throwReatomError(1,"derived action call"),anAction.pipe(mapState((ctx,depState,prevDepState,prevState=fallback)=>isAction?(ctx.spy=void 0,depState.reduce((acc,v)=>{const payload=map(ctx,v.payload,v.params);return payload===SKIP?acc:[...acc,{params:[v],payload:payload}]},prevState)):depState.reduce((acc,{payload:payload,params:params})=>{const state=map(ctx,payload,params,acc);return state===SKIP?acc:state},prevState),mapName(anAction,"mapPayload",name))));return theAtom.__reatom.isAction=isAction,theAtom},mapPayloadAwaited=function(){var a=[].slice.call(arguments);return anAction=>{const isAction=0===a.length||"function"==typeof a[0],[fallback,map=((ctx,v)=>v),name]=isAction?[[],a[0],a[1]]:a,params=isAction?[]:[fallback];return params.push((ctx,promise)=>promise instanceof Promise?(__thenReatomed(ctx,promise,(v,read,actualize)=>actualize(ctx,ctx.cause.proto,(patchCtx,patch)=>{patch.cause=ctx.cause.cause;const payload=map(ctx,v);patch.state=isAction?[...patch.state,{params:[v],payload:payload}]:payload})),SKIP):map(ctx,promise),mapName(anAction,"mapPayloadAwaited",name)),(anAction.onFulfill??anAction).pipe(mapPayload(...params))}},mapInput=(mapper,name)=>anAtom=>action(function(ctx){return anAtom(ctx,mapper(ctx,...[].slice.call(arguments,1)))},mapName(anAtom,"mapInput",name)),toAtom=(fallback,name)=>anAction=>mapPayload(fallback,(ctx,v)=>v,mapName(anAction,"toAtom",name))(anAction),withOnUpdate=cb=>anAtom=>(onUpdate(anAtom,cb),anAtom),toAction=(map,name)=>anAtom=>{throwReatomError(anAtom.__reatom.isAction,"atom expected"),"string"==typeof map&&(name=map,map=void 0),map = map || ((ctx,v)=>v);const theAction=atom(ctx=>{const isInit=0===ctx.cause.pubs.length,state=ctx.spy(anAtom);return isInit?[]:[{params:[state],payload:map(ctx,state)}]},mapName(anAtom,"toAction",name));return theAction.__reatom.isAction=!0,theAction.deps=[anAtom],theAction};export{SKIP,bind,combine,debounce,delay,effect,filter,mapInput,mapPayload,mapPayloadAwaited,mapState,match,onLensUpdate,parseAtoms,plain,readonly,sample,select,throttle,toAction,toAtom,toLens,withOnUpdate,withReset};
//# sourceMappingURL=index.mjs.map
