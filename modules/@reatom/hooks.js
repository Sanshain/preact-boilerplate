import{atom,throwReatomError,action}from"@reatom/core";import{noop,merge,toAbortError}from"@reatom/utils";import{abortCauseContext}from"@reatom/effects";const getRootCause=cause=>null===cause.cause?cause:getRootCause(cause.cause),isSameCtx=(ctx1,ctx2)=>getRootCause(ctx1.cause)===getRootCause(ctx2.cause),addOnConnect=(anAtom,cb)=>(anAtom.__reatom.connectHooks = anAtom.__reatom.connectHooks ??new Set).add(cb),addOnDisconnect=(anAtom,cb)=>(anAtom.__reatom.disconnectHooks = anAtom.__reatom.disconnectHooks ??new Set).add(cb),addOnUpdate=(anAtom,cb)=>(anAtom.__reatom.updateHooks = anAtom.__reatom.updateHooks ??new Set).add(cb),withInit=createState=>anAtom=>{const{initState:initState,isAction:isAction}=anAtom.__reatom;return throwReatomError(isAction,"action state is not manageable"),anAtom.__reatom.initState=ctx=>createState(ctx,initState),anAtom},onConnect=(anAtom,cb)=>{const connectHook=ctx=>{const cause=merge(ctx.get(read=>read(anAtom.__reatom)),{cause:getRootCause(ctx.cause)}),controller=new AbortController;abortCauseContext.set(cause,controller);const cleanup=cb(merge(ctx,{cause:cause,controller:controller,isConnected:()=>isConnected(ctx,anAtom)}));cleanup instanceof Promise&&cleanup.catch(noop);const cleanupHook=_ctx=>{isSameCtx(ctx,_ctx)&&disconnectHooks.delete(cleanupHook)&&connectHooks.has(connectHook)&&(controller.abort(toAbortError(`${anAtom.__reatom.name} disconnect`)),"function"==typeof cleanup&&cleanup())},disconnectHooks=addOnDisconnect(anAtom,cleanupHook)},connectHooks=addOnConnect(anAtom,connectHook);return()=>connectHooks.delete(connectHook)},onDisconnect=(anAtom,cb)=>onConnect(anAtom,ctx=>()=>cb(ctx)),onUpdate=(anAtom,cb=noop)=>(anAtom.deps??[]).reduce((acc,dep)=>{const un=onUpdate(dep,ctx=>ctx.get(anAtom));return()=>{un(),acc()}},((anAtom,cb=noop)=>{const hook=(ctx,patch)=>{let{state:state}=patch;if(anAtom.__reatom.isAction){if(0===patch.state.length)return;const call=state.at(-1);state=call.payload,patch.params=call.params}cb(ctx,state,patch)},hooks=addOnUpdate(anAtom,hook);return()=>hooks.delete(hook)})(anAtom,cb)),spyChange=(ctx,anAtom,handler)=>{let isChanged=!1;return ctx.spy(anAtom,(newState,prevState)=>{isChanged=!0,handler?.(newState,prevState)}),isChanged},controlConnection=(initState=!0,name)=>anAtom=>{name = name ??`${anAtom.__reatom.name}.controlConnection`;const isActiveAtom=atom(initState,`${name}._isActiveAtom`);return Object.assign({toggleConnection:action((ctx,value)=>isActiveAtom(ctx,state=>value??!state),`${name}.toggleConnection`)},atom((ctx,state)=>ctx.spy(isActiveAtom)?ctx.spy(anAtom):state,name))},isConnected=(ctx,{__reatom:proto})=>ctx.get(read=>{const cache=proto.patch??read(proto);return!!cache&&cache.subs.size+cache.listeners.size>0}),initializations=atom(null,"initializations");initializations.__reatom.initState=()=>new WeakMap;const isInit=ctx=>{const inits=ctx.get(initializations);return inits.has(ctx.cause.proto)?inits.get(ctx.cause.proto)===ctx.cause:(inits.set(ctx.cause.proto,ctx.cause),!0)};export{addOnConnect,addOnDisconnect,addOnUpdate,controlConnection,getRootCause,isConnected,isInit,isSameCtx,onConnect,onDisconnect,onUpdate,spyChange,withInit};
//# sourceMappingURL=index.mjs.map
