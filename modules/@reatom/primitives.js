import{atom,action,throwReatomError,isAtom,__count}from"@reatom/core";import{assign,isObject,omit}from"@reatom/utils";const withAssign=getProps=>target=>assign(target,getProps(target,target.__reatom.name)),reatomArray=(initState=[],name)=>atom(initState,name).pipe(withAssign((target,name)=>({toReversed:action(ctx=>target(ctx,prev=>prev.slice().reverse()),`${name}.toReversed`),toSorted:action((ctx,compareFn)=>target(ctx,prev=>prev.slice().sort(compareFn)),`${name}.toSorted`),toSpliced:action(function(ctx,start,deleteCount){return target(ctx,state=>((state=state.slice()).splice(start,deleteCount,...[].slice.call(arguments,3)),state))},`${name}.toSpliced`),with:action((ctx,i,value)=>target(ctx,state=>(Object.is(state.at(i),value)||((state=state.slice())[i]=value),state)),`${name}.with`)}))),reatomBoolean=(init=!1,name)=>atom(init,name).pipe(withAssign((target,name)=>({toggle:action(ctx=>target(ctx,prev=>!prev),`${name}.toggle`),setTrue:action(ctx=>target(ctx,!0),`${name}.setTrue`),setFalse:action(ctx=>target(ctx,!1),`${name}.setFalse`),reset:action(ctx=>target(ctx,init),`${name}.reset`)}))),reatomEnum=(variants,options={})=>{const{name:name,format:format="camelCase",initState:initState=variants[0]}="string"==typeof options?{name:options}:options,stateAtom=atom(initState,name),enumAtom=Object.assign((ctx,update)=>{const state=stateAtom(ctx,update);return throwReatomError(!variants.includes(state),`invalid enum value "${state}" for "${name}" enum`),state},stateAtom),cases=enumAtom.enum={};enumAtom.reset=action(ctx=>enumAtom(ctx,initState),`${name}.reset`);for(const variant of variants){cases[variant]=variant;const setterName=variant.replace(/^./,firstLetter=>"set"+("camelCase"===format?firstLetter.toUpperCase():`_${firstLetter}`));enumAtom[setterName]=action(ctx=>enumAtom(ctx,variant),`${name}.${setterName}`)}return enumAtom},reatomMap=(initState=new Map,name)=>atom(initState,name).pipe(withAssign((target,name)=>{const getOrCreate=action((ctx,key,value)=>(actions.set(ctx,key,value),value),`${name}.getOrCreate`),actions={get:(ctx,key)=>ctx.get(target).get(key),getOrCreate:(ctx,key,creator)=>actions.has(ctx,key)?actions.get(ctx,key):getOrCreate(ctx,key,creator()),has:(ctx,key)=>ctx.get(target).has(key),set:action((ctx,key,value)=>target(ctx,prev=>{const valuePrev=prev.get(key);return Object.is(valuePrev,value)&&(void 0!==value||prev.has(key))?prev:new Map(prev).set(key,value)}),`${name}.set`),delete:action((ctx,key)=>target(ctx,prev=>{if(!prev.has(key))return prev;const next=new Map(prev);return next.delete(key),next}),`${name}.delete`),clear:action(ctx=>target(ctx,new Map),`${name}.clear`),reset:action(ctx=>target(ctx,initState),`${name}.reset`)};return actions})),readonly=anAtom=>({...anAtom}),LL_PREV=Symbol("Reatom linked list prev"),LL_NEXT=Symbol("Reatom linked list next"),addLL=(state,node,after)=>{node!==after&&(after?(node[LL_PREV]=after,node[LL_NEXT]=after[LL_NEXT],after[LL_NEXT]=node,state.tail===after&&(state.tail=node)):(node[LL_PREV]=null,node[LL_NEXT]=state.head,state.head&&(state.head[LL_PREV]=node),state.tail||(state.tail=node),state.head=node),state.size++)},removeLL=(state,node)=>{state.head===node?state.head=node[LL_NEXT]:null!==node[LL_PREV]&&(node[LL_PREV][LL_NEXT]=node[LL_NEXT]),state.tail===node?state.tail=node[LL_PREV]:null!==node[LL_NEXT]&&(node[LL_NEXT][LL_PREV]=node[LL_PREV]),node[LL_PREV]=null,node[LL_NEXT]=null,state.size--},swapLL=(state,a,b)=>{if(a===b)return;if(state.head===b)return swapLL(state,b,a);const prevA=a[LL_PREV],nextA=a[LL_NEXT],prevB=b[LL_PREV],nextB=b[LL_NEXT];nextA===b?(a[LL_NEXT]=nextB,b[LL_PREV]=prevA,b[LL_NEXT]=a,a[LL_PREV]=b,nextB&&(nextB[LL_PREV]=a),prevA&&(prevA[LL_NEXT]=b)):nextB===a?(b[LL_NEXT]=nextA,a[LL_PREV]=prevB,a[LL_NEXT]=b,b[LL_PREV]=a,nextA&&(nextA[LL_PREV]=b),prevB&&(prevB[LL_NEXT]=a)):(prevA&&(prevA[LL_NEXT]=b),nextA&&(nextA[LL_PREV]=b),prevB&&(prevB[LL_NEXT]=a),nextB&&(nextB[LL_PREV]=a),a[LL_PREV]=prevB,a[LL_NEXT]=nextB,b[LL_PREV]=prevA,b[LL_NEXT]=nextA),state.head===a?state.head=b:state.head===b&&(state.head=a),state.tail===a?state.tail=b:state.tail===b&&(state.tail=a)},moveLL=(state,node,after)=>{removeLL(state,node),addLL(state,node,after)},clearLL=state=>{for(;state.tail;)removeLL(state,state.tail)},toArray=(head,prev)=>{let arr=[],i=0;for(;head;)void 0!==prev&&prev[i]!==head&&(prev=void 0),arr.push(head),head=head[LL_NEXT],i++;return arr.length===prev?.length?prev:arr},reatomLinkedList=(options,name=__count("reatomLinkedList"))=>{const{create:userCreate,initState:initState=[],key:key}="function"==typeof options?{create:options}:options,_name=name,isLL=node=>!!node&&LL_NEXT in node&&LL_PREV in node,throwModel=node=>throwReatomError(isLL(node),"The data is already in a linked list."),throwNotModel=node=>throwReatomError(!isLL(node),"The passed data is not a linked list node.");let STATE=null;const linkedList=atom(STATE,name);linkedList.__reatom.initState=()=>{try{STATE={size:0,version:1,changes:[],head:null,tail:null};for(const node of initState)throwModel(node),addLL(STATE,node,STATE.tail);return STATE}finally{STATE=null}};const batchFn=(ctx,cb)=>{if(STATE)return cb(ctx);STATE=linkedList(ctx,({head:head,tail:tail,size:size,version:version})=>({size:size,version:version+1,changes:[],head:head,tail:tail}));try{return cb(ctx)}finally{STATE=null}},batch=action(batchFn,`${name}._batch`),create=action(function(ctx){return batchFn(ctx,()=>{const node=userCreate(ctx,...[].slice.call(arguments,1));return throwReatomError(!isObject(node)&&"function"!=typeof node,`reatomLinkedList can operate only with objects or functions, received "${node}".`),throwModel(node),addLL(STATE,node,STATE.tail),STATE.changes.push({kind:"create",node:node}),node})},`${name}.create`),remove=action((ctx,node)=>batchFn(ctx,()=>(throwNotModel(node),(null!==node[LL_PREV]||null!==node[LL_NEXT]||STATE.tail===node)&&(removeLL(STATE,node),STATE.changes.push({kind:"remove",node:node}),!0))),`${name}.remove`),swap=action((ctx,a,b)=>batchFn(ctx,()=>{throwNotModel(a),throwNotModel(b),a!==b&&(swapLL(STATE,a,b),STATE.changes.push({kind:"swap",a:a,b:b}))}),`${name}.swap`),move=action((ctx,node,after)=>batchFn(ctx,()=>{throwNotModel(node),moveLL(STATE,node,after),STATE.changes.push({kind:"move",node:node,after:after})}),`${name}.move`),clear=action(ctx=>batchFn(ctx,()=>{clearLL(STATE),STATE.changes.push({kind:"clear"})}),`${name}.clear`),array=atom((ctx,state=[])=>toArray(ctx.spy(linkedList).head,state),`${name}.array`),map=key?atom(ctx=>new Map(ctx.spy(array).map(node=>{const keyValue=node[key];return[isAtom(keyValue)?ctx.spy(keyValue):keyValue,node]}))):void 0;return Object.assign(linkedList,{batch:batch,create:create,remove:remove,swap:swap,move:move,clear:clear,find:(ctx,cb)=>{for(let{head:head}=ctx.get(linkedList);head;head=head[LL_NEXT])if(cb(head))return head;return null},array:array,map:map,reatomMap:(cb,options={})=>{const{name:name=__count(`${_name}.reatomMap`),...hooks}="string"==typeof options?{name:options}:options,mapList=atom((ctx,mapList)=>{throwReatomError(STATE,"Can't compute the map of the linked list inside the batching.");const ll=ctx.spy(linkedList);if(!mapList||ll.version-1>mapList.version){mapList&&hooks.onClear?.(ctx,mapList),mapList={size:ll.size,version:ll.version,changes:[],head:null,tail:null,map:new WeakMap};for(let head=ll.head;head;head=head[LL_NEXT]){const node=cb(ctx,head);addLL(mapList,node,mapList.tail),mapList.map.set(head,node),hooks.onCreate?.(ctx,node)}mapList.size=ll.size}else{mapList={head:mapList.head,tail:mapList.tail,size:mapList.size,version:ll.version,changes:[],map:mapList.map};for(const change of ll.changes)switch(change.kind){case"create":{const node=cb(ctx,change.node);addLL(mapList,node,mapList.tail),mapList.map.set(change.node,node),mapList.changes.push({kind:"create",node:node}),hooks.onCreate?.(ctx,node);break}case"remove":{const node=mapList.map.get(change.node);removeLL(mapList,node),mapList.map.delete(change.node),mapList.changes.push({kind:"remove",node:node}),hooks.onRemove?.(ctx,node,change.node);break}case"swap":{const a=mapList.map.get(change.a),b=mapList.map.get(change.b);swapLL(mapList,a,b),mapList.changes.push({kind:"swap",a:a,b:b}),hooks.onSwap?.(ctx,{a:a,b:b});break}case"move":{const node=mapList.map.get(change.node),after=change.after?mapList.map.get(change.after):null;moveLL(mapList,node,after),mapList.changes.push({kind:"move",node:node,after:after}),hooks.onMove?.(ctx,node);break}case"clear":hooks.onClear?.(ctx,mapList),clearLL(mapList),mapList.changes.push({kind:"clear"});break;default:throw new Error(`Unhandled linked list change "${change}"`)}}return throwReatomError(mapList.size!==ll.size,"Inconsistent linked list, is's a bug, please report an issue"),mapList},name),array=atom((ctx,state=[])=>toArray(ctx.spy(mapList).head,state),`${name}.array`);return Object.assign(mapList,{array:array,__reatomLinkedList:!0})},__reatomLinkedList:!0}).pipe(readonly)},isLinkedListAtom=thing=>!0===thing?.__reatomLinkedList,reatomNumber=(initState=0,name)=>atom(initState,name).pipe(withAssign((target,name)=>({increment:action((ctx,by=1)=>target(ctx,prev=>prev+by),`${name}.increment`),decrement:action((ctx,by=1)=>target(ctx,prev=>prev-by),`${name}.decrement`),random:action(ctx=>target(ctx,Math.random()),`${name}.decrement`),reset:action(ctx=>target(ctx,initState),`${name}.reset`)}))),reatomRecord=(initState,name)=>atom(initState,name).pipe(withAssign(target=>({merge:action((ctx,slice)=>target(ctx,prev=>{for(const key in prev)if(!Object.is(prev[key],slice[key]))return{...prev,...slice};return prev}),`${name}.merge`),omit:action(function(ctx){var keys=[].slice.call(arguments,1);return target(ctx,prev=>keys.some(key=>key in prev)?omit(prev,keys):prev)},`${name}.omit`),reset:action(function(ctx){var keys=[].slice.call(arguments,1);return target(ctx,prev=>{if(0===keys.length)return initState;const next={};let changed=!1;for(const key in prev)keys.includes(key)?key in initState?(next[key]=initState[key],changed = changed ||!Object.is(prev[key],initState[key])):changed = changed ||key in prev:next[key]=prev[key];return changed?next:prev})},`${name}.reset`)}))),reatomSet=(initState=new Set,name)=>atom(initState,name).pipe(withAssign((target,name)=>({add:action((ctx,el)=>target(ctx,prev=>prev.has(el)?prev:new Set(prev).add(el)),`${name}.add`),set:action((ctx,el)=>target(ctx,prev=>prev.has(el)?prev:new Set(prev).add(el)),`${name}.set`),delete:action((ctx,el)=>target(ctx,prev=>{if(!prev.has(el))return prev;const next=new Set(prev);return next.delete(el),next}),`${name}.delete`),clear:action(ctx=>target(ctx,prev=>0===prev.size?prev:new Set),`${name}.clear`),reset:action(ctx=>target(ctx,initState),`${name}.reset`),intersection:action((ctx,set)=>target(ctx,prev=>prev.intersection(set)),`${name}.intersection`),union:action((ctx,set)=>target(ctx,prev=>prev.union(set)),`${name}.union`),difference:action((ctx,set)=>target(ctx,prev=>prev.difference(set)),`${name}.difference`),symmetricDifference:action((ctx,set)=>target(ctx,prev=>prev.symmetricDifference(set)),`${name}.symmetricDifference`),toggle:action((ctx,el)=>target(ctx,prev=>{if(!prev.has(el))return new Set(prev).add(el);const next=new Set(prev);return next.delete(el),next}),`${name}.toggle`),has:(ctx,el)=>ctx.get(target).has(el),isSubsetOf:(ctx,set)=>ctx.get(target).isSubsetOf(set),isSupersetOf:(ctx,set)=>ctx.get(target).isSupersetOf(set),isDisjointFrom:(ctx,set)=>ctx.get(target).isDisjointFrom(set),size:ctx=>ctx.get(target).size}))),reatomString=(init="",name)=>atom(init,name).pipe(withAssign((target,name)=>({reset:action(ctx=>target(ctx,init),`${name}.reset`)}))),withComputed=computed=>anAtom=>{const prevComputed=anAtom.__reatom.computer;return anAtom.__reatom.computer=(ctx,state)=>(prevComputed&&(state=prevComputed(ctx,state)),computed(ctx,state)),anAtom},withReducers=reducers=>anAtom=>Object.keys(reducers).reduce((anAtom,k)=>(anAtom[k]=action(function(ctx){return anAtom(ctx,reducers[k](ctx.get(anAtom),...[].slice.call(arguments,1)))},`${anAtom.__reatom.name}._${k}`),anAtom),anAtom);export{LL_NEXT,LL_PREV,isLinkedListAtom,reatomArray,reatomBoolean,reatomEnum,reatomLinkedList,reatomMap,reatomNumber,reatomRecord,reatomSet,reatomString,withAssign,withComputed,withReducers};
//# sourceMappingURL=index.mjs.map
