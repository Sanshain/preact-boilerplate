import React from "react"; import { throwReatomError, isAtom, atom, isAction, action, createCtx, __count } from "@reatom/core"; import { bind } from "@reatom/lens"; import { abortCauseContext, withAbortableSchedule } from "@reatom/effects"; import { toAbortError } from "@reatom/utils"; const useIsomorphicEffect = "undefined" != typeof document ? React.useLayoutEffect : React.useEffect; let getName = type => { let Component = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED?.ReactCurrentOwner?.current?.type, name = Component?.displayName ?? Component?.name; return name ? `Component.${name}.${type}` : `_${type}` }, batch = cb => cb(); const setupBatch = newBatch => { batch = newBatch }, withBatching = ctx => { let queue = []; return { ...ctx, subscribe: (anAtom, cb) => ctx.subscribe(anAtom, cb && (value => Promise.resolve(queue.push(() => cb(value))).then(length => length === queue.length && batch(() => queue.splice(0).forEach(cb => cb()))))) } }, reatomContext = React.createContext(null), useCtx = () => { let ctx = React.useContext(reatomContext); return throwReatomError(!ctx, "ctx is not set, you probably forgot to specify the ctx provider"), ctx }; let bindBind = (ctx, fn) => bind(ctx, fn); const useCtxBind = () => bind(useCtx(), bindBind), useAtom = (anAtom, userDeps = [], options = {}) => { let { name: name, subscribe: subscribe = !0 } = "boolean" == typeof options ? { subscribe: options } : options, ctx = useCtx(), deps = [ctx]; isAtom(anAtom) && deps.push(anAtom); let ref = React.useMemo(() => { let atomName = getName(name ?? "useAtom#" + typeof anAtom), depsAtom = atom([], `${atomName}._depsAtom`), theAtom = anAtom; isAtom(theAtom) || (theAtom = atom("function" == typeof anAtom ? (ctx, state) => (ctx.spy(depsAtom), ref.anAtom(ctx, state)) : anAtom, atomName)); let update = "function" == typeof theAtom ? function () { return batch(() => theAtom(ctx, ...[].slice.call(arguments))) } : void 0; return { theAtom: theAtom, depsAtom: depsAtom, update: update, sub: cb => ctx.subscribe(theAtom, cb), get: () => ctx.get(theAtom), subscribe: subscribe, anAtom: anAtom } }, deps); ref.anAtom = anAtom; let { theAtom: theAtom, depsAtom: depsAtom, update: update, sub: sub, get: get } = ref; return ctx.get(() => { if (!isAtom(anAtom)) { const prevDeps = ctx.get(depsAtom); (userDeps.length !== prevDeps.length || userDeps.some((dep, i) => !Object.is(dep, prevDeps[i]))) && ("function" == typeof anAtom ? depsAtom(ctx, userDeps) : update(ctx, anAtom)) } return [subscribe ? React.useSyncExternalStore(sub, get, get) : get(), update, theAtom, ctx] }) }, useAtomCreator = (creator, deps = [], options) => useAtom(React.useMemo(creator, deps), [], options), useUpdate = (cb, deps) => { const ctx = useCtx(); return React.useEffect(() => { const call = ctx => { cb(ctx, ...deps.map(thing => isAtom(thing) ? ctx.get(thing) : thing)) }; return call(ctx), deps.forEach((thing, i) => isAtom(thing) && (thing.__reatom.updateHooks = thing.__reatom.updateHooks ?? new Set).add(call)), () => deps.forEach((thing, i) => isAtom(thing) && thing.__reatom.updateHooks.delete(call)) }, deps.concat(ctx)), null }, useAction = (fn, deps = [], name) => { throwReatomError("function" != typeof fn, 'invalid "fn"'), deps = deps ?? []; let ctx = useCtx(); deps.push(ctx), isAction(fn) && deps.push(fn); let ref = React.useMemo(() => { let theAction = isAction(fn) ? fn : action(function () { return ref.fn(...[].slice.call(arguments)) }, name ?? getName("useAction")); return { fn: fn, cb: function () { return batch(() => theAction(ctx, ...[].slice.call(arguments))) } } }, deps); return useIsomorphicEffect(() => { ref.fn = fn }), ref.cb }, useCreateCtx = extension => { const ctxRef = React.useRef(null); return ctxRef.current || (ctxRef.current = createCtx(), extension?.(ctxRef.current)), ctxRef.current }, reatomComponent = (Component, name) => { name = name ? `Component.${name}` : __count("Component"); let rendering = !1; return Object.defineProperty(props => { const { controller: controller, propsAtom: propsAtom, renderAtom: renderAtom } = React.useMemo(() => { const controller = new AbortController, propsAtom = atom({}, `${name}._propsAtom`), renderAtom = atom((ctx, state) => { const { pubs: pubs } = ctx.cause, props = ctx.spy(propsAtom); if (rendering) { const initCtxRef = React.useRef(); if (!initCtxRef.current) { const initCtx = initCtxRef.current = withAbortableSchedule(ctx); abortCauseContext.set(initCtx.cause, controller) } const initCtx = initCtxRef.current; props.ctx = { get: ctx.get, spy: ctx.spy, schedule: ctx.schedule, subscribe: ctx.subscribe, cause: initCtx.cause, bind: bind(initCtx, bindBind) }; const result = Component(props); return "object" != typeof result || null === result || Symbol.iterator in result ? React.createElement(React.Fragment, null, result) : result } for (let i = 1; i < pubs.length; i++)ctx.spy({ __reatom: pubs[i].proto }); return { ...state, REATOM_DEPS_CHANGE: !0 } }, `${name}._renderAtom`); return { controller: controller, propsAtom: propsAtom, renderAtom: renderAtom } }, []), ctx = useCtx(), [, forceUpdate] = React.useState({}); return React.useEffect(() => { let finalController = controller; if (finalController.signal.aborted) { const initCause = ctx.get(propsAtom).ctx.cause; abortCauseContext.set(initCause, finalController = new AbortController) } const unsubscribe = ctx.subscribe(renderAtom, element => { element.REATOM_DEPS_CHANGE && forceUpdate(element) }); return () => { unsubscribe(), finalController.abort(toAbortError(`${name} unmount`)) } }, [ctx, renderAtom]), ctx.get(() => { propsAtom(ctx, { ...props }); try { return rendering = !0, ctx.get(renderAtom) } finally { rendering = !1 } }) }, "name", { value: name }) }, promisesValues = new WeakMap, useAtomPromise = theAtom => { const forceUpdate = React.useReducer(s => s + 1, 0)[1], promise = useAtom(theAtom)[0]; promisesValues.has(promise) || promisesValues.set(promise, promise.then(v => { promisesValues.set(promise, v), forceUpdate() })); const value = promisesValues.get(promise); if (value instanceof Promise) throw value; return value };
export { reatomComponent, reatomContext, setupBatch, useAction, useAtom, useAtomCreator, useAtomPromise, useCreateCtx, useCtx, useCtxBind, useIsomorphicEffect, useUpdate, withBatching }